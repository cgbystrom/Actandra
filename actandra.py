# Naive implementation of an activity stream service using Cassandra.
# Just a proof of concept and not anything that is for production use.
# Probably flawed in many ways like proper key usage, writing and features.

import pycassa
from pycassa.cassandra.ttypes import NotFoundException
from pycassa.system_manager import *
import datetime
import uuid
import json
import time

KEYSPACE = 'Actandra'
POOL = pycassa.connect(KEYSPACE)

SUBSCRIBERS = pycassa.ColumnFamily(POOL, 'Subscribers')
STREAMS = pycassa.ColumnFamily(POOL, 'Streams')
ACTIVITIES = pycassa.ColumnFamily(POOL, 'Activities')
COMMENTS = pycassa.ColumnFamily(POOL, 'Comments')
LIKES = pycassa.ColumnFamily(POOL, 'Likes')

def sync_cassandra():
    sys = SystemManager()

    if KEYSPACE in sys.list_keyspaces():
        msg = 'Looks like you already have a %s keyspace.\n' % KEYSPACE
        msg += 'Do you want to delete it and recreate it?\n'
        msg += 'All current data will be deleted! (y/n): '
        resp = raw_input(msg)
        if not resp or resp[0] != 'y':
            print "Ok, then we're done here."
            return
        sys.drop_keyspace(KEYSPACE)

    sys.create_keyspace(KEYSPACE, replication_factor=1)
    sys.create_column_family(KEYSPACE, 'Subscribers', comparator_type=BYTES_TYPE)
    sys.create_column_family(KEYSPACE, 'Streams', comparator_type=LONG_TYPE)
    sys.create_column_family(KEYSPACE, 'Activities', comparator_type=BYTES_TYPE)
    sys.create_column_family(KEYSPACE, 'Comments', comparator_type=LONG_TYPE)
    sys.create_column_family(KEYSPACE, 'Likes', comparator_type=LONG_TYPE)

    print 'All done!'

def _truncate():
    SUBSCRIBERS.truncate()
    STREAMS.truncate()
    ACTIVITIES.truncate()
    COMMENTS.truncate()
    LIKES.truncate()

def subscribe(from_stream_id, to_stream_id):
    """
    Subscribes an activity stream to another activity stream
    Example: subscribe('elvis', 'hector') will subscribe user 'elvis' to activities generated by 'hector'
    """
    # FIXME: Set a hard limit on max subscribers!
    # Valueless column
    SUBSCRIBERS.insert(str(from_stream_id), {str(to_stream_id): '\0'})

def unsubscribe(from_stream_id, to_stream_id):
    """
    Unsubscribes an activity stream from another activity stream
    Example: unsubscribe('elvis', 'hector') will unsubscribe user 'elvis' from activities generated by 'hector'
    """
    return SUBSCRIBERS.remove(str(from_stream_id), [str(to_stream_id)])

def get_subscribers(stream_id):
  """
  Get all subscribers for a given activity stream
  Example: get_subscribers('elvis') will get the all users subscribing to user 'elvis' activity stream
  """
    try:
        return SUBSCRIBERS.get(str(stream_id)).keys()
    except NotFoundException:
        return []

def add_activity_to_stream(stream_id, actor, message):
    """
    Publishes an activity to an activity stream and all the subscribing activity streams
    Example: publish_activity('hector', 'Ranked up to level 27') will publish the activity
    to activity stream for user 'hector' and all his subscribers.
    """
    # TODO: Validate actor and message

    activity_id = str(uuid.uuid4())
    ACTIVITIES.insert(str(activity_id), {'message': message, 'actor': json.dumps(actor), 'numComments': '0'})

    stream_ids = get_subscribers(stream_id)
    ts = long(time.time() * 1e6)
    activity_entry = {ts: activity_id}
    rows = {str(stream_id): activity_entry}
    for sid in stream_ids:
    rows[str(sid)] = activity_entry

    STREAMS.batch_insert(rows)

def remove_activity_from_stream(stream_id, activity_id):
    STREAMS.remove(str(stream_id), [str(activity_id)])

def remove_activity(activity_id):
    # Warning: calling this without calling remove_activity_from_stream may cause inconsistencies
    # Only use this when you know what you are doing
    ACTIVITIES.remove(str(activity_id))


def get_activity_stream(stream_id, limit):
    """
    Get an activity stream
    Example: get_stream('elvis', 10) will get the ten latest activities in user 'elvis' activity stream
    """
    activity_ids = STREAMS.get(str(stream_id), column_count=limit, column_reversed=True).values()
    return ACTIVITIES.multiget(activity_ids)

def add_comment(activity_id, actor, comment):
    # TODO: Validate actor (must contain ID) and comment
    # TODO: Enforce caps on num comments
    ts = long(time.time() * 1e6)
    COMMENTS.insert(str(activity_id), {ts: json.dumps({'actor': actor, 'comment': comment})})
    num_comments = COMMENTS.get_count(str(activity_id))
    # num_comments when written may differ from actual comments since writes can happen in between.
    ACTIVITIES.insert(str(activity_id), {'numComments': str(num_comments)})


def remove_comment(activity_id):
    COMMENTS.remove(str(activity_id))

def get_commments(activity_id, limit):
    json_comments = COMMENTS.get(str(activity_id), column_count=limit, column_reversed=True)

    comments = []
    for ts, json_data in json_comments.iteritems():
    c = json.loads(json_data)
    c['published'] = ts
    comments.append(c)

    return comments

def add_like(activity_id, comment):
    pass

def remove_like(activity_id):
    pass

def get_likes(activity_id, limit):
    pass

